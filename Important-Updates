Here we keep all the choices we took, some implementation difficulties that we faced and the ways we solved them.


1) Include Statement
=====================
	In order to be able to include external libraries to our main module, we keep a list of all the included files in the program, (also not allowing reincludes). We lex and then parse each file of this list separately and then merge them together when we create the AST.

2) Function Call and Commas
============================
	Initially while developing the parser, the function call commas where recognised as binary operation commas, so we had to create a recursive function call rule that absorbs the parameters one by one.

3) Testing
===========
	We implemented a testing program that runs on all test input, prints their output in files in the output folder (depending on the debug level) and counts how many of them are correct. 

4) Function Binding
====================

	We consider every function with the same name but any difference in types a different function
	Example: 
	// The following are two different functions
	int pipi(char a);
	int pipi(byref char a);

5) Functions Scope
========================
	Every function declared in some block is able to see EVERY other variable inside this scope ( even if the variable is declared after it)

6) Array Immutability
======================
	Arrays are not considered L-Values
	The following is not allowed:
	char a[5];
	a = "foo\n";
	PS: Allowing this behaviour is very easy and requires a small change at the new_l_val_check function

7) String Immutability 
=======================
	String Constants are implemented as global constants only only once, and then are referenced by pointers. That is why constant strings are immutable.

8) Nested Functions
====================
	Nested functions have access to the outer functions' scope; we achieved this by passing a struct with the scope of the outer functions on the inside ones. 

9) Runtime Checks Implementation
=================================
	Explain

10) Library function names and signatures
==========================================
	We recompiled the library functions so that their names conform to the compielr standards which are.
	<function_name>-<#args>-<arg1_type>-...-<argn_type>-<uid>
	We used this  name policy so that there can exist many functions with the same name but with different arguments in the same scope and also many functions with the same name and the same arguments in different scopes.

11) Reals Policy
========================
	We have a midlayer of dynamically linked C code in order to be able to represent reals in
	Edsger and convert them to IEEE 754 80 bits. We first compile the library and then use it from the 
	python script. Cause otherwise we could not represent them with the prerequisite precision.
	You can see further details in our imlementation.

12) Pointer Arithmetic
=======================
	We allow most of the pointer arithmetic
	Example:
	*(p+1)
	*(p+3-i) where i is an int